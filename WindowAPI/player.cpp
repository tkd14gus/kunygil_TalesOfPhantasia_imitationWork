#include "stdafx.h"
#include "player.h"

HRESULT player::init()
{
	// 플레이어 구조체를 init시키면 초기화 시켜준다.
	this->settingTagPlayer();

	_stage = RectMake(0, 500, WINSIZEX, WINSIZEY);

	//프레임이미지초기화
	_frameCount = 0;
	_frameIndex = 0;

	//무적시간 초기화
	//_immoTime = 0;

	//_enemyHP = 3;


	//_enemyX = 500;
	//_enemyY = 400;

	// 게임이 시작할 때 전투씬이 아니다.
	_isBattle = false;
	// 플레이어는 제일 먼저 시작할 때 아래를 바라보고 있다.
	_direct = 1;

	return S_OK;
}

void player::release()
{
}

void player::update()
{
	if (_isBattle)
	{
		//실시간 플레이어 위치 및 속도
		_player.rc = RectMakeCenter(_player.x, _player.y, 75, 80);
		if (!(_state == pATTACK || _state == pJUMP))
		{
			_player.attXK = 0;
			_player.attYK = 0;
		}
		if (_player.sight == true)
		{
			_player.attack = RectMake(_player.rc.right - 20, _player.rc.top, _player.attXK, _player.attYK);
			//_player.jumpAttack = RectMake(_rcPlayer.right - 20, _rcPlayer.top, 50, 160);
		}
		else if (_player.sight == false)
		{
			_player.attack = RectMake(_player.rc.left - 20, _player.rc.top, _player.attXK, _player.attYK);
			//_player.jumpAttack = RectMake(_rcPlayer.left - 20, _rcPlayer.top, 50, 160);
		}

		if (_state == pWALK)
		{
			_player.speed = 3.0f;
		}
		else if (_state == pRUN)
		{
			_player.speed = 5.0f;
		}

		//실시간 적의 위치
		//_TESTenemy = RectMake(_enemyX, _enemyY, 50, 50);

		//적사각형 중점
		//_enemyCenterX = _enemyX + float((_TESTenemy.right - _TESTenemy.left) / 2);
		//_enemyCenterY = _enemyY + float((_TESTenemy.bottom - _TESTenemy.top) / 2);

		//test - HP down
		if (INPUT->GetKeyDown('Q'))
		{
			_player.hp--;
			if (_player.hp <= 0)
			{
				_frameIndex = 0;
			}
		}

		//sight left & walk left
		if (INPUT->GetKey(VK_LEFT))
		{
			if (_state == pATTACK)
			{
				_state = pATTACK;
			}
			else if (_state == pGUARD)
			{
				_player.sight = 0;
				_state = pGUARD;
			}
			else if (_state == pJUMP)
			{
				_state = pJUMP;
				_player.x -= 3;
			}
			else
			{
				if (INPUT->GetKey(VK_SHIFT))
				{
					_player.sight = 0;				 //플레이어 시점 - 왼쪽
					_state = pRUN;			 //플레이어 상태 - 뛰기
					_player.x -= _player.speed;                    //플레이어 좌표 변화
				}
				else
				{
					_player.sight = 0;				 //플레이어 시점 - 왼쪽
					_state = pWALK;			 //플레이어 상태 - 걷기
					_player.x -= _player.speed;                    //플레이어 좌표 변화
				}
			}
		}
		//state idle
		if (INPUT->GetKeyUp(VK_LEFT) && _state != pATTACK)
		{

			if (_state != pGUARD)
			{
				_state = pIDLE;
			}
		}
		//sight right & walk right
		if (INPUT->GetKey(VK_RIGHT))
		{
			if (_state == pATTACK)
			{
				_state = pATTACK;
			}
			else if (_state == pGUARD)
			{
				_player.sight = 1;
				_state = pGUARD;
			}
			else if (_state == pJUMP)
			{
				_state = pJUMP;
				_player.x += 3;
			}
			else
			{
				if (INPUT->GetKey(VK_SHIFT))
				{
					_player.sight = 1;				 //플레이어 시점 - 오른쪽
					_state = pRUN;			         //플레이어 상태 - 뛰기
					_player.x += _player.speed;                  //플레이어 좌표 변화
				}
				else
				{
					_player.sight = 1;				 //플레이어 시점 - 오른쪽
					_state = pWALK;			         //플레이어 상태 - 걷기
					_player.x += _player.speed;                  //플레이어 좌표 변화
				}
			}
		}
		//state idle
		if (INPUT->GetKeyUp(VK_RIGHT) && _state != pATTACK)
		{

			if (_state != pGUARD)
			{
				_state = pIDLE;
			}
		}


		//test - state attack -> 베기와 찌르기, 점프시에는 점프 베기 찌르기등으로 추가예정
		if (INPUT->GetKeyDown('Z') && _state != pDEAD && _state != pJUMP)
		{
			_state = pATTACK;
			if (_state != pATTACK)
			{
				_frameIndex = 0;
			}

			_player.attXK = 50;
			_player.attYK = 130;

		}

		//test - state guard
		if (INPUT->GetKey('X') && _state != pJUMP)
		{
			_state = pGUARD;
		}
		if (INPUT->GetKeyUp('X'))
		{
			_state = pIDLE;
		}

		// state jump
		if (INPUT->GetKeyDown('C') && _state != pJUMP)
		{
			_frameIndex = 0;
			_state = pJUMP;
			_player.gravity = 0.0f;
			_player.attXK = 50;
			_player.attYK = 130;
		}

		if (_state == pJUMP)
		{
			_player.x += cosf(PI / 2) * 1;
			_player.y += -sinf(PI / 2) * 5 + _player.gravity;
			_player.gravity += 0.1f;
		}



		//test - state win
		if (INPUT->GetKeyDown(VK_F5))
		{
			_state = pWIN;
		}

		//바닥에 닿게 되었을때
		if (_player.y > 460 && _state == pJUMP)
		{
			_player.gravity = 0.0f;
			_state = pIDLE;
			_player.y = 460;
		}
		//공중에서 다른 모션이 적용되지 않도록 설정
		if (_player.y < 460 && _state != pJUMP)
		{
			_state = pJUMP;
		}

		//플레이어 사망
		if (_player.hp <= 0)
		{
			_state = pDEAD;
		}



		//RECT temp;
		////공격 타격범위와 적과의 충돌
		//if (IntersectRect(&temp, &_player.attack, &_TESTenemy))
		//{
		//	_player.attXK = 0;
		//	_player.attYK = 0;
		//	_enemyHP -= 1;
		//}
	}
	else
	{
		// 위쪽키를 눌렀을 때
		if (INPUT->GetKey(VK_UP))
		{
			//움직이면 먼저 상태를 walk로 바꿔준다.
			_state = pWALK;
			//움직이는 뱡항을 조정해준다.
			//위쪽이므로 0.
			_direct = 0;
			//위쪽으로 움직이므로 Y좌표만 --시켜준다.
			_player.inGameY--;
		}
		// 위쪽키를 땠을 떄
		if (INPUT->GetKeyUp(VK_UP))
		{
			//움직임을 idle로 바꿔준다.
			_state = pIDLE;
		}
		// 아래쪽키를 눌렀을 때
		if (INPUT->GetKey(VK_DOWN))
		{
			//움직이면 먼저 상태를 walk로 바꿔준다.
			_state = pWALK;
			//움직이는 뱡항을 조정해준다.
			//위쪽이므로 1
			_direct = 1;
			//위쪽으로 움직이므로 Y좌표만 ++시켜준다.
			_player.inGameY++;
		}
		// 아래쪽키를 땠을 떄
		if (INPUT->GetKeyUp(VK_DOWN))
		{
			//움직임을 idle로 바꿔준다.
			_state = pIDLE;
		}
		// 왼쪽키를 눌렀을 때
		if (INPUT->GetKey(VK_LEFT))
		{
			//움직이면 먼저 상태를 walk로 바꿔준다.
			_state = pWALK;
			//움직이는 뱡항을 조정해준다.
			//위쪽이므로 2.
			_direct = 2;
			//위쪽으로 움직이므로 X좌표만 --시켜준다.
			_player.inGameX--;
		}
		// 왼쪽키를 땠을 떄
		if (INPUT->GetKeyUp(VK_LEFT))
		{
			//움직임을 idle로 바꿔준다.
			_state = pIDLE;
		}
		// 오른쪽키를 눌렀을 때
		if (INPUT->GetKey(VK_RIGHT))
		{
			//움직이면 먼저 상태를 walk로 바꿔준다.
			_state = pWALK;
			//움직이는 뱡항을 조정해준다.
			//위쪽이므로 3.
			_direct = 3;
			//위쪽으로 움직이므로 X좌표만 ++시켜준다.
			_player.inGameX++;
		}
		// 오른쪽키를 땠을 떄
		if (INPUT->GetKeyUp(VK_RIGHT))
		{
			//움직임을 idle로 바꿔준다.
			_state = pIDLE;
		}

		// 플레이어의 위치를 계속 초기화 한다.
		_player.rc = RectMakeCenter(_player.inGameX, _player.inGameY, 64, 128);
		// 플레이어의 문 충돌용 렉트 위치를 계속 초기화 한다.
		this->settingPlayerDoorRect();
		//_playerDoorRcP = RectMakeCenter(_player.inGameX, _player.inGameY, 64 + 48 * 2, 128 + 48 * 2);

	}

	_frameCount++;

}

void player::render()
{
	//배틀일 때
	if (_isBattle)
	{
		Rectangle(getMemDC(), _stage);

		Rectangle(getMemDC(), _player.rc);		//플레이어 타격범위 사각형

		Rectangle(getMemDC(), _player.attack);		//플레이어 타격범위 사각형

		this->animation();					//플레이어 모션 애니메이션
											//배틀일 땐 애니메이션으로 렌더하니까 뒤에 둔다.

		char chr1[100];
		sprintf(chr1, "player hp : %d", _player.hp);
		TextOut(getMemDC(), 100, 720, chr1, strlen(chr1));
	}
	else
	{
		this->animation();					//플레이어 모션 애니메이션
											//배틀이 아닐땐 프레임X, Y값을 바꿔주기 때문에 가장 먼저 함수를 불러준다.

		//문 충돌을 위한 렉트 보여주기
		FrameRect(getMemDC(), _playerDoorRc, RGB(255, 0, 0));

		// 플레이어가 걷는 상태라면
		if (_state == pWALK)
		{
			//만약 플레이어의 x값이 WINSIZEX / 2보다 크고, (48 * 120 - WINSIZEX / 2)보다 작을때(x값이 가운데일 때)
			if (_player.inGameX >= WINSIZEX / 2 && _player.inGameX <= (48 * 120 - WINSIZEX / 2))
			{
				//만약 y값도 가운데라면
				if (_player.inGameY >= WINSIZEY / 2 && _player.inGameY <= (48 * 150 - WINSIZEY / 2))
				{
					//렉트할 때 중심에 그리는 것이 아니라 left, top의 좌표이므로 절반 크기만큼 빼준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), WINSIZEX / 2 - 32, WINSIZEY / 2 - 64);
				}
				//y값이 위쪽에 치우쳐져 있다면
				else if (_player.inGameY < WINSIZEY / 2)
				{
					//x는 중심값, y는 캐릭터의 top값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), WINSIZEX / 2 - 32, _player.rc.top);
				}
				//y값이 아래쪽에 치우쳐져 있다면
				else
				{
					//x는 중심값, y는 (48 * 150 - WINSIZEY)값에서 플레이어 top값을 뺀 값을 준다.
					//_player.rc.top - (48 * 150 - WINSIZEY)인 이유는 플레이어의 위치를 WINSIZEY안에 그려줘야 하는데
					//y좌표는 이미  WINSIZEY를 초과한 상태이다.
					//때문에 현재 좌표에서 전체 맵 크기인 48 * 150와 화면 Y축 크기인 WINSIZEY을 뺀 값을
					//플레이어 좌표에서 빼주면 화면에 보이면서  WINSIZEY 안에서 플레이어를 랜더한 수 있다.
					//이후로 나오는 Y좌표와 X좌표 모두 같은 원리이다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), WINSIZEX / 2 - 32, _player.rc.top - (48 * 150 - WINSIZEY));
				}

			}
			//만약 플레이어의 y값이 WINSIZEY / 2보다 크고, (48 * 150 - WINSIZEY / 2)보다 작을 때(y값이 가운데일 때)
			else if (_player.inGameY >= WINSIZEY / 2 && _player.inGameY <= (48 * 150 - WINSIZEY / 2))
			{
				//만약 x값이 왼쪽이라면
				if (_player.inGameX < WINSIZEX / 2)
				{
					//플레이어의 x값은 플레이어의 값을, y값은 중심값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left, WINSIZEY / 2 - 64);
				}
				//만약 x값이 오른쪽이라면
				else if (_player.inGameX > (48 * 120 - WINSIZEX / 2))
				{
					//플레이어의 x값은 _player.rc.left - (48 * 120 - WINSIZEX)값을 , y값은 중심값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left - (48 * 120 - WINSIZEX), WINSIZEY / 2 - 64);
				}
			}
			//플래이어 x가 왼쪽에 치우쳐져 있을 때
			else if (_player.inGameX < WINSIZEX / 2)
			{
				//만약 y가 위쪽에 치우쳐져 있다면
				if (_player.inGameY < WINSIZEY / 2)
				{
					//x플레이어의 원래 x값, y는 캐릭터의 top값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left, _player.rc.top);
				}
				//y값이 아래쪽에 치우쳐져 있다면
				else if (_player.inGameY > (48 * 150 - WINSIZEY / 2))
				{
					//x플레이어의 원래 x값, y는 캐릭터의  _player.rc.top - (48 * 150 - WINSIZEY)값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left, _player.rc.top - (48 * 150 - WINSIZEY));
				}
			}
			//플레이어 x가 오른쪽에 치우쳐져 있을 때
			else if (_player.inGameX > (48 * 120 - WINSIZEX / 2))
			{
				//만약 y가 위쪽에 치우쳐져 있다면
				if (_player.inGameY < WINSIZEY / 2)
				{
					//플레이어x는  _player.rc.left - (48 * 120 - WINSIZEX)값, y는 캐릭터의 top값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left - (48 * 120 - WINSIZEX), _player.rc.top);
				}
				//y값이 아래쪽에 치우쳐져 있다면
				else if (_player.inGameY > (48 * 150 - WINSIZEY / 2))
				{
					//플레이어의x는 _player.rc.left - (48 * 120 - WINSIZEX)값, y는 캐릭터의  _player.rc.top - (48 * 150 - WINSIZEY)값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left - (48 * 120 - WINSIZEX), _player.rc.top - (48 * 150 - WINSIZEY));
				}
			}
		}
		// 플레이어가 멈춰있는 상태라면 currentX좌표는 항상 2번으로 멈춰있다.
		// 때문에 walk일때와 다르게 뒤에 2,  _directP); 를 추가로 더해준다.
		else
		{
			//만약 플레이어의 x값이 WINSIZEX / 2보다 크고, (48 * 120 - WINSIZEX)보다 작을때(x값이 가운데일 때)
			if (_player.inGameX >= WINSIZEX / 2 && _player.inGameX <= (48 * 120 - WINSIZEX / 2))
			{
				//만약 y값도 가운데라면
				if (_player.inGameY >= WINSIZEY / 2 && _player.inGameY <= (48 * 150 - WINSIZEY / 2))
				{
					//렉트할 때 중심에 그리는 것이 아니라 left, top의 좌표이므로 절반 크기만큼 빼준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), WINSIZEX / 2 - 32, WINSIZEY / 2 - 64, 2, _direct);
				}
				//y값이 위쪽에 치우쳐져 있다면
				else if (_player.inGameY < WINSIZEY / 2)
				{
					//x는 중심값, y는 캐릭터의 top값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), WINSIZEX / 2 - 32, _player.rc.top, 2, _direct);
				}
				//y값이 아래쪽에 치우쳐져 있다면
				else
				{
					//플레이어의x는 중심에서 넓이의 절반만큼 뺀 WINSIZEX / 2 - 32를 주고,, y는 캐릭터의  _player.rc.top - (48 * 150 - WINSIZEY)값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), WINSIZEX / 2 - 32, _player.rc.top - (48 * 150 - WINSIZEY), 2, _direct);
				}

			}
			//만약 플레이어의 y값이 WINSIZEY / 2보다 크고, (48 * 150 - WINSIZEY / 2)보다 작을 때(y값이 가운데일 때)
			else if (_player.inGameY >= WINSIZEY / 2 && _player.inGameY <= (48 * 150 - WINSIZEY / 2))
			{
				//만약 x값이 왼쪽이라면
				if (_player.inGameX < WINSIZEX / 2)
				{
					//플레이어의 x값은 플레이어의 값을, y값은 중심값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left, WINSIZEY / 2 - 64, 2, _direct);
				}
				//만약 x값이 오른쪽이라면
				else if (_player.inGameX > (48 * 120 - WINSIZEX / 2))
				{
					//플레이어의 x값은 _player.rc.left - (48 * 120 - WINSIZEX / 2)값을 , y값은 중심값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left - (48 * 120 - WINSIZEX), WINSIZEY / 2 - 64, 2, _direct);
				}
			}
			//플래이어 x가 왼쪽에 치우쳐져 있을 때
			else if (_player.inGameX < WINSIZEX / 2)
			{
				//만약 y가 위쪽에 치우쳐져 있다면
				if (_player.inGameY < WINSIZEY / 2)
				{
					//x플레이어의 원래 x값, y는 캐릭터의 top값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left, _player.rc.top, 2, _direct);
				}
				//y값이 아래쪽에 치우쳐져 있다면
				else if (_player.inGameY > (48 * 150 - WINSIZEY / 2))
				{
					//x플레이어의 원래 x값, y는 캐릭터의  _player.rc.top - (48 * 150 - WINSIZEY / 2)값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left, _player.rc.top - (48 * 150 - WINSIZEY), 2, _direct);
				}
			}
			//플레이어 x가 오른쪽에 치우쳐져 있을 때
			else if (_player.inGameX > (48 * 120 - WINSIZEX / 2))
			{
				//만약 y가 위쪽에 치우쳐져 있다면
				if (_player.inGameY < WINSIZEY / 2)
				{
					//플레이어x는  _player.rc.left - (48 * 120 - WINSIZEX / 2)값, y는 캐릭터의 top값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left - (48 * 120 - WINSIZEX), _player.rc.top, 2, _direct);
				}
				//y값이 아래쪽에 치우쳐져 있다면
				else if (_player.inGameY > (48 * 150 - WINSIZEY / 2))
				{
					//플레이어의x는 _player.rc.left - (48 * 120 - WINSIZEX / 2)값, y는 캐릭터의  _player.rc.top - (48 * 150 - WINSIZEY / 2)값을 준다.
					IMAGEMANAGER->frameRender("cress", getMemDC(), _player.rc.left - (48 * 120 - WINSIZEX), _player.rc.top - (48 * 150 - WINSIZEY), 2, _direct);
				}
			}
		}

	}



}

void player::animation()
{
	//배틀일 때
	if (_isBattle)
	{
		switch (_state)
		{
		case pIDLE:		//대기상태
			//좌
			if (_player.sight == false)
			{
				IMAGEMANAGER->frameRender("mIdle", getMemDC(), _player.rc.left, _player.rc.top);
				_frameCount++;
				_player.idle->setFrameY(0);
				if (_frameCount % 8 == 0)
				{
					_frameIndex++;
					if (_frameIndex > 2)
					{
						_frameIndex = 0;
					}
					_player.idle->setFrameX(_frameIndex);
				}
			}
			//우
			if (_player.sight == true)
			{
				IMAGEMANAGER->frameRender("mIdle", getMemDC(), _player.rc.left, _player.rc.top);
				_frameCount++;
				_player.idle->setFrameY(1);
				if (_frameCount % 8 == 0)
				{
					_frameIndex++;
					if (_frameIndex > 2)
					{
						_frameCount = 0;
						_frameIndex = 0;
					}
					_player.idle->setFrameX(_frameIndex);
				}
			}
			break;
		case pWALK:		//걷기
			if (_player.sight == false)
			{
				IMAGEMANAGER->frameRender("walk", getMemDC(), _player.rc.left - 10, _player.rc.top);
				_frameCount++;
				_player.walk->setFrameY(0);
				if (_frameCount % 8 == 0)
				{
					_frameIndex++;
					if (_frameIndex > 4)
					{
						_frameCount = 0;
						_frameIndex = 0;
					}
					_player.walk->setFrameX(_frameIndex);
				}
			}
			if (_player.sight == true)
			{
				IMAGEMANAGER->frameRender("walk", getMemDC(), _player.rc.left + 10, _player.rc.top);
				_frameCount++;
				_player.walk->setFrameY(1);
				if (_frameCount % 8 == 0)
				{
					_frameIndex++;
					if (_frameIndex > 4)
					{
						_frameCount = 0;
						_frameIndex = 0;
					}
					_player.walk->setFrameX(_frameIndex);
				}
			}
			break;
		case pRUN:		//달리기
			if (_player.sight == false)
			{
				IMAGEMANAGER->frameRender("run", getMemDC(), _player.rc.left - 10, _player.rc.top - 10);
				_frameCount++;
				_player.run->setFrameY(1);
				if (_frameCount % 8 == 0)
				{
					_frameIndex++;
					if (_frameIndex > 4)
					{
						_frameCount = 0;
						_frameIndex = 0;
					}
					_player.run->setFrameX(_frameIndex);
				}
			}
			if (_player.sight == true)
			{
				IMAGEMANAGER->frameRender("run", getMemDC(), _player.rc.left, _player.rc.top - 10);
				_frameCount++;
				_player.run->setFrameY(0);
				if (_frameCount % 8 == 0)
				{
					_frameIndex++;
					if (_frameIndex > 4)
					{
						_frameCount = 0;
						_frameIndex = 0;
					}
					_player.run->setFrameX(_frameIndex);
				}
			}
			break;
		case pATTACK:	//공격은 한번공격후 다시 대기상태로 들어가게 했음
			if (_player.sight == false)
			{
				IMAGEMANAGER->frameRender("slash", getMemDC(), _player.rc.left - 15, _player.rc.top - 20);
				_frameCount++;
				_player.atkSlash->setFrameY(0);
				if (_frameCount % 8 == 0)
				{
					IMAGEMANAGER->findImage("slash")->setFrameY(0);
					_frameIndex++;
					if (_frameIndex > 5)
					{
						_frameCount = 0;
						_frameIndex = 0;
						_state = pIDLE;	//한번공격후 상태대기자세로
					}
					_player.atkSlash->setFrameX(_frameIndex);
				}
			}
			if (_player.sight == true)
			{
				IMAGEMANAGER->frameRender("slash", getMemDC(), _player.rc.left - 10, _player.rc.top - 15);
				_frameCount++;
				_player.atkSlash->setFrameY(1);
				if (_frameCount % 8 == 0)
				{
					IMAGEMANAGER->findImage("slash")->setFrameY(1);
					_frameIndex++;
					if (_frameIndex > 5)
					{
						_frameIndex = 0;
						_state = pIDLE;
					}
					_player.atkSlash->setFrameX(_frameIndex);
				}
			}
			break;
		case pJUMP:
			if (_player.sight == false)
			{
				IMAGEMANAGER->frameRender("jump", getMemDC(), _player.rc.left, _player.rc.top - 20);
				_frameCount++;
				_player.jump->setFrameY(1);
				if (_frameCount % 15 == 0)
				{
					IMAGEMANAGER->findImage("jump")->setFrameY(1);
					_frameIndex++;
					if (_frameIndex > 3)
					{
						_frameCount = 0;
						_frameIndex = 3;
					}
					_player.jump->setFrameX(_frameIndex);
				}
			}
			if (_player.sight == true)
			{
				IMAGEMANAGER->frameRender("jump", getMemDC(), _player.rc.left, _player.rc.top - 20);
				_frameCount++;
				_player.jump->setFrameY(0);
				if (_frameCount % 15 == 0)
				{
					IMAGEMANAGER->findImage("jump")->setFrameY(0);
					_frameIndex++;
					if (_frameIndex > 3)
					{
						_frameCount = 0;
						_frameIndex = 3;
					}
					_player.jump->setFrameX(_frameIndex);
				}
			}
			break;
		case pGUARD:		//가드
			if (_player.sight == false)
			{
				IMAGEMANAGER->frameRender("guard", getMemDC(), _player.rc.left, _player.rc.top);
				_frameCount++;
				_player.atkSlash->setFrameY(0);
				if (_frameCount % 8 == 0)
				{
					IMAGEMANAGER->findImage("guard")->setFrameY(0);
					_frameIndex++;
					if (_frameIndex > 1)
					{
						_frameCount = 0;
						_frameIndex = 0;
					}
					_player.atkSlash->setFrameX(_frameIndex);
				}
			}
			if (_player.sight == true)
			{
				IMAGEMANAGER->frameRender("guard", getMemDC(), _player.rc.left, _player.rc.top);
				_frameCount++;
				_player.atkSlash->setFrameY(1);
				if (_frameCount % 8 == 0)
				{
					IMAGEMANAGER->findImage("guard")->setFrameY(1);
					_frameIndex++;
					if (_frameIndex > 1)
					{
					}
					_player.atkSlash->setFrameX(_frameIndex);
				}
			}
			break;
		case pDEAD:		//사망시에는 hp = 0이되어 사망하며 유령상태 유지 - 이후 재시작등 수정 가능
			if (_player.sight == false)
			{
				IMAGEMANAGER->frameRender("dead", getMemDC(), _player.rc.left, _player.rc.top);
				_frameCount++;
				_player.dead->setFrameY(0);
				if (_frameCount % 30 == 0)
				{
					IMAGEMANAGER->findImage("dead")->setFrameY(0);
					_frameIndex++;
					if (_frameIndex > 3)
					{
						_frameIndex = 2;
					}
					_player.dead->setFrameX(_frameIndex);
				}
			}
			if (_player.sight == true)
			{
				IMAGEMANAGER->frameRender("dead", getMemDC(), _player.rc.left, _player.rc.top);
				_frameCount++;
				_player.dead->setFrameY(1);
				if (_frameCount % 30 == 0)
				{
					IMAGEMANAGER->findImage("dead")->setFrameY(1);
					_frameIndex++;
					if (_frameIndex > 3)
					{
						_frameIndex = 2;
					}
					_player.dead->setFrameX(_frameIndex);
				}
			}
			break;
		case pWIN:
			IMAGEMANAGER->frameRender("win", getMemDC(), _player.rc.left - 20, _player.rc.top - 54);
			_frameCount++;
			_player.win->setFrameY(0);
			if (_frameCount % 20 == 0)
			{
				IMAGEMANAGER->findImage("win")->setFrameY(0);
				_frameIndex++;
				_player.win->setFrameX(_frameIndex);
			}
			break;
		}
	}
	//배틀이 아닐 때
	else
	{
	// 플레이어가 걷는 상태라면
	if (_state == pWALK)
	{
		// _directP가 바라보는 방향인데 바라보는 방향에 따라
		// 프레임이미지의 Y좌표가 달라짐.
		switch (_direct)
		{
			//위쪽키를 눌렀을 떄
		case 0:
			if (_frameCount % 8 == 0)
			{
				IMAGEMANAGER->findImage("cress")->setFrameY(0);
				_frameIndex++;
				if (_frameIndex > 5)
				{
					_frameIndex = 0;
				}
				IMAGEMANAGER->findImage("cress")->setFrameX(_frameIndex);
			}
			break;
			//아래쪽키를 눌렀을 떄
		case 1:
			if (_frameCount % 8 == 0)
			{
				IMAGEMANAGER->findImage("cress")->setFrameY(1);
				_frameIndex++;
				if (_frameIndex > 5)
				{
					_frameIndex = 0;
				}
				IMAGEMANAGER->findImage("cress")->setFrameX(_frameIndex);
			}
			break;
			//왼쪽키를 눌렀을 떄
		case 2:
			if (_frameCount % 8 == 0)
			{
				IMAGEMANAGER->findImage("cress")->setFrameY(2);
				_frameIndex++;
				if (_frameIndex > 5)
				{
					_frameIndex = 0;
				}
				IMAGEMANAGER->findImage("cress")->setFrameX(_frameIndex);
			}
			break;
			//오른쪽키를 눌렀을 때
		case 3:
			if (_frameCount % 8 == 0)
			{
				IMAGEMANAGER->findImage("cress")->setFrameY(3);
				_frameIndex++;
				if (_frameIndex > 5)
				{
					_frameIndex = 0;
				}
				IMAGEMANAGER->findImage("cress")->setFrameX(_frameIndex);
			}
			break;
		}
	}
	}
}

void player::setPlayerRect(int x, int y)
{
	_player.inGameX = x;
	_player.inGameY = y;
	_player.rc = RectMakeCenter(_player.inGameX, _player.inGameY, 64, 128);
}

void player::settingTagPlayer()
{

	//이미지 초기화
	_player.idle = IMAGEMANAGER->addFrameImage("mIdle", "Images/mainplayer/idle.bmp", 150, 156, 2, 2);
	_player.walk = IMAGEMANAGER->addFrameImage("walk", "Images/mainplayer/walk.bmp", 360, 156, 4, 2);
	_player.run = IMAGEMANAGER->addFrameImage("run", "Images/mainplayer/run&stop.bmp", 450, 188, 5, 2);
	_player.guard = IMAGEMANAGER->addFrameImage("guard", "Images/mainplayer/guard.bmp", 66, 156, 1, 2);

	//공격모션
	_player.atkSlash = IMAGEMANAGER->addFrameImage("slash", "Images/mainplayer/atk_slash.bmp", 525, 262, 5, 2);
	//_player.atkstab = IMAGEMANAGER->addFrameImage("stab", "Images/mainplayer/atk_stab.bmp", 396, 120, 4, 2);
	_player.jump = IMAGEMANAGER->addFrameImage("jump", "Images/mainplayer/jump_slash.bmp", 445, 262, 5, 2);

	_player.dead = IMAGEMANAGER->addFrameImage("dead", "Images/mainplayer/dead.bmp", 264, 156, 4, 2);

	_player.win = IMAGEMANAGER->addFrameImage("win", "Images/mainplayer/victory.bmp", 401, 157, 4, 1);


	//플레이어 초기 좌표 설정
	_player.x = 200;
	_player.y = 460;
	//플레이어 사각형


	_player.sight = true;		//초기 설정 - 오른쪽 방향
	//_player.atkTime = 0.0f;     //타격시간
	_state = pIDLE;		        //초기 설정 - 대기상태


	_player.speed = 3.0f;


	_player.hp = _player.maxHp = 5;			//초기 설정 - 체력 5
	_player.tp = _player.maxTp = 5;			//초기 설정 - TP 5
	_player.lv = 1;
	_player.attXK = 0;
	_player.attYK = 0;

	//인게임에서 사용할 좌표는 배틀과 겹치면 안되니까 따로 빼놓자.
	_player.inGameX = (48 * 120) - WINSIZEX;
	_player.inGameY = (48 * 150) - WINSIZEY;
	//플레이어 렉트를 초기화 해준다.
	_player.rc = RectMakeCenter(_player.inGameX, _player.inGameY, 64, 128);
}

void player::settingPlayerDoorRect()
{
	//계산신의 위의 render에 frameRender와 같음.
	//궁금하면 거기 봐볼것.
	//다만 rect크기가 두개 타일 크기인 48 * 2만큼 더 크므로
	//그것을 감안하여 계산함.

	//만약 플레이어의 x값이 WINSIZEX / 2보다 크고, (48 * 120 - WINSIZEX / 2)보다 작을때(x값이 가운데일 때)
	if (_player.inGameX >= WINSIZEX / 2 && _player.inGameX <= (48 * 120 - WINSIZEX / 2))
	{
		//만약 y값도 가운데라면
		if (_player.inGameY >= WINSIZEY / 2 && _player.inGameY <= (48 * 150 - WINSIZEY / 2))
		{
			_playerDoorRc = RectMake(WINSIZEX / 2 - 80, WINSIZEY / 2 - 112, 64 + 48 * 2, 128 + 48 * 2);
		}
		//y값이 위쪽에 치우쳐져 있다면
		else if (_player.inGameY < WINSIZEY / 2)
		{
			_playerDoorRc = RectMake(WINSIZEX / 2 - 80, _player.rc.top - 48, 64 + 48 * 2, 128 + 48 * 2);
		}
		//y값이 아래쪽에 치우쳐져 있다면
		else
		{
			_playerDoorRc = RectMake(WINSIZEX / 2 - 80, _player.rc.top - (48 * 150 - WINSIZEY) - 48, 64 + 48 * 2, 128 + 48 * 2);
		}

	}
	//만약 플레이어의 y값이 WINSIZEY / 2보다 크고, (48 * 150 - WINSIZEY / 2)보다 작을 때(y값이 가운데일 때)
	else if (_player.inGameY >= WINSIZEY / 2 && _player.inGameY <= (48 * 150 - WINSIZEY / 2))
	{
		//만약 x값이 왼쪽이라면
		if (_player.inGameX < WINSIZEX / 2)
		{
			_playerDoorRc = RectMake(_player.rc.left - 48, WINSIZEY / 2 - 112, 64 + 48 * 2, 128 + 48 * 2);
		}
		//만약 x값이 오른쪽이라면
		else if (_player.inGameX > (48 * 120 - WINSIZEX / 2))
		{
			_playerDoorRc = RectMake(_player.rc.left - (48 * 120 - WINSIZEX) - 48, WINSIZEY / 2 - 112, 64 + 48 * 2, 128 + 48 * 2);
		}
	}
	//플래이어 x가 왼쪽에 치우쳐져 있을 때
	else if (_player.inGameX < WINSIZEX / 2)
	{
		//만약 y가 위쪽에 치우쳐져 있다면
		if (_player.inGameY < WINSIZEY / 2)
		{
			_playerDoorRc = RectMake(_player.rc.left - 48, _player.rc.top - 48, 64 + 48 * 2, 128 + 48 * 2);
		}
		//y값이 아래쪽에 치우쳐져 있다면
		else if (_player.inGameY > (48 * 150 - WINSIZEY / 2))
		{
			_playerDoorRc = RectMake(_player.rc.left - 48, _player.rc.top - (48 * 150 - WINSIZEY) - 48, 64 + 48 * 2, 128 + 48 * 2);
		}
	}
	//플레이어 x가 오른쪽에 치우쳐져 있을 때
	else if (_player.inGameX > (48 * 120 - WINSIZEX / 2))
	{
		//만약 y가 위쪽에 치우쳐져 있다면
		if (_player.inGameY < WINSIZEY / 2)
		{
			_playerDoorRc = RectMake(_player.rc.left - (48 * 120 - WINSIZEX) - 48, _player.rc.top - 48, 64 + 48 * 2, 128 + 48 * 2);
		}
		//y값이 아래쪽에 치우쳐져 있다면
		else if (_player.inGameY > (48 * 150 - WINSIZEY / 2))
		{
			_playerDoorRc = RectMake(_player.rc.left - (48 * 120 - WINSIZEX) - 48, _player.rc.top - (48 * 150 - WINSIZEY) - 48, 64 + 48 * 2, 128 + 48 * 2);
		}
	}
}

void player::spinPlayer()
{
	//stateWindow가 참이되면 플레이어를 update 안하기 때문에 여기서 프레임카운터를 증가시킨다.
	_frameCount++;

	//40프레임이 지날때 마다 보는 방향을 바꿔준다.
	//순서는 아래 좌 위 우이다.
	if (_frameCount % 500 == 0)
	{
		if (_direct == 0)
			_direct = 3;
		else if (_direct == 1)
			_direct++;
		else if (_direct == 2)
			_direct = 0;
		else
			_direct = 1;
	}
	//
	this->animation();
}

HRESULT subplayer::init()
{

								//이미지 초기화
	//대기 모션
	_subPlayer.idle = IMAGEMANAGER->addFrameImage("subIdle", "Images/subplayer/chester_battel_idle.bmp", 288, 180, 2, 1);
	//걷기 모션
	_subPlayer.walk = IMAGEMANAGER->addFrameImage("subWalk", "Images/subplayer/chester_battel_walk.bmp", 576, 180, 4, 1);
	//달리기 모션
	_subPlayer.run = IMAGEMANAGER->addFrameImage("subRun", "Images/subplayer/chester_battel_run.bmp", 576, 180, 4, 1);
	//원거리 공격 모션
	_subPlayer.atkshot = IMAGEMANAGER->addFrameImage("subShot", "Images/subplayer/chester_battel_shoot.bmp", 1152, 180, 8, 1);
	//근접 공격 모션
	_subPlayer.atkmelee = IMAGEMANAGER->addFrameImage("subMelee", "Images/subplayer/chester_battel_physical.bmp", 288, 180, 2, 1);
	//사망 모션
	_subPlayer.dead = IMAGEMANAGER->addFrameImage("subDead", "Images/subplayer/chester_battel_dead.bmp", 432, 180, 3, 1);
	//승리 모션
	_subPlayer.win = IMAGEMANAGER->addFrameImage("subWin", "Images/subplayer/chester_battel_win.bmp", 432, 180, 3, 1);
	//화살 이미지
	_arrow._img = IMAGEMANAGER->addImage("arrow", "Images/subplayer/arrow.bmp", 76, 11);
								//이미지 초기화 끝
	_walkingDirect = IMAGEMANAGER->addFrameImage("chester", "Images/subplayer/chester_walking_direct.bmp", 165, 256, 5, 4);




	//플레이어 초기 좌표 설정
	_subPlayer.x = 100;
	_subPlayer.y = 370;
	//플레이어 사각형



	_subPlayer.sight = true;	//초기 설정 - 오른쪽 방향
	_state = pIDLE;		        //초기 설정 - 대기상태

	_arrow._chargeTime = 0.0f;	//화살준비 시간. (일정 시간에 도달하면 발사)
	_arrow._bShoot = false;		//화살이 발사되었는지 판단하는 bool 변수.
								//true일 경우 발사된 것으로 판단하므로 false로 초기화.
	_arrow._speed = 0.0f;		//화살이 날아가는 속도 초기화.

	_melee = false;				//거리가 일정 거리가 될경우 true값이 되어 공격시 근접공격으로 전환

	_subPlayer.hp = _subPlayer.maxHp = 5;			//초기 설정 - 체력 5
	_subPlayer.tp = _subPlayer.maxTp = 5;
	_subPlayer.lv = 1;
	_subPlayer.attXK = 0;
	_subPlayer.attYK = 0;


	//프레임이미지초기화
	_frameCount = 0;
	_frameIndex = 0;

	return S_OK;
}

void subplayer::release()
{

}

void subplayer::update()
{
	this->animation();

	//ai의 위치
	_subPlayer.rc = RectMake(_subPlayer.x, _subPlayer.y, 125, 130);

	//중점의 위치
	_arrow._point.x = (float(_subPlayer.rc.left) + float((_subPlayer.rc.right - _subPlayer.rc.left) / 2));	//x좌표
	_arrow._point.y = (float(_subPlayer.rc.top) + float((_subPlayer.rc.bottom - _subPlayer.rc.top) / 2));	//y좌표
	_arrow._rc = RectMakeCenter(_arrow._point.x - 1, _arrow._point.y - 1, 17, 11);		//화살 Rect 설정.

	//실시간 거리
	//ai와 적의 거리
	//_distance = sqrt(pow(_cX - _mainplayer->getenemyCenterx(), 2) + pow(_cY - _mainplayer->getenemyCentery(), 2));

	//이동 상태에 따른 속도 변경
	if (_state == pWALK) { _subPlayer.speed = 1.0f; }	//pWALK일 때는 속도를 1.0f로 설정
	if (_state == pRUN) { _subPlayer.speed = 3.0f; }	//pRun일 때는 속도를 3.0f로 설정
	
	//거리조절
	if (_distance > 700)
	{
		_state = pWALK;
		_subPlayer.x++;
	}
	else
	{
		if (_distance >= 50) { _melee = false; }	//거리가 50 이상이면 활로 공격
		else { _melee = true; }						//거리가 50 미만이면 근접 공격
		_state = pATTACK;	//공격 상태로 전환
	}

	//공격
	if (_state == pATTACK)
	{
		//근접 상태일 경우 근접 공격을 한다.
		if(_melee)
		{
			_frameIndex = 0;
		}
		//근접이 아닐시 활을 쏜다.
		else
		{
			//화살 장전 시간이 30.0 이상이고 발사되지 않았을 때
			if (_arrow._chargeTime > 30.0f && !_arrow._bShoot)
			{
				_arrow._bShoot = true;		//화살 발사
				_arrow._chargeTime = 0.0f;	//화살 장전 시간을 초기화.
				_frameIndex = 0;			//frameIndex를 0으로 초기화.
			}
			else
			{
				//화살충전
				_arrow._chargeTime += 0.1f;
			}
		}
	}


	//화살이 날아갈시 화살의 좌표 이동
	if (_arrow._bShoot == true)
	{
		_arrow._point.x += cosf(PI / 2) * 2 + _arrow._speed;
		_arrow._point.y += -sinf(PI / 2) * 2;
		_arrow._speed += 2.1f;
	}

	//화살충돌
	//RECT temp;
	//if (IntersectRect(&temp, &_mainplayer->getenemyRect(), &_arrow))
	//{
	//	_arrowIs = false;
	//}
}

void subplayer::render()
{
	Rectangle(getMemDC(), _subPlayer.rc);

	switch (_state)
	{
	case pIDLE:
		if (_subPlayer.sight)
		{
			IMAGEMANAGER->findImage("subIdle")->frameRender(getMemDC(), _subPlayer.rc.left - 10, _subPlayer.rc.top - 30);
		}
		else
		{
			IMAGEMANAGER->findImage("subIdle")->
				scaleFrameRender(getMemDC(), _subPlayer.rc.left - 10, _subPlayer.rc.top - 30, 
					_subPlayer.idle->getFrameX(), _subPlayer.idle->getFrameY(), -1.0F);
		}
		break;
	case pWALK:
		if (_subPlayer.sight)
		{
			IMAGEMANAGER->findImage("subWalk")->frameRender(getMemDC(), _subPlayer.rc.left - 20, _subPlayer.rc.top - 30);
		}
		else
		{
			IMAGEMANAGER->findImage("subWalk")->
				scaleFrameRender(getMemDC(), _subPlayer.rc.left - 20, _subPlayer.rc.top - 30,
					_subPlayer.walk->getFrameX(), _subPlayer.walk->getFrameY(), -1.0F);
		}
		break;
	case pATTACK:
		if (_melee)
		{
			if (_subPlayer.sight)
			{
				IMAGEMANAGER->findImage("subMelee")->frameRender(getMemDC(), _subPlayer.rc.left - 10, _subPlayer.rc.top - 30);
			}
			else
			{
				IMAGEMANAGER->findImage("subMelee")->
					scaleFrameRender(getMemDC(), _subPlayer.rc.left - 10, _subPlayer.rc.top - 30,
						_subPlayer.atkmelee->getFrameX(), _subPlayer.atkmelee->getFrameY(), -1.0F);
			}
		}
		else
		{
			if (_subPlayer.sight)
			{
				IMAGEMANAGER->findImage("subShot")->frameRender(getMemDC(), _subPlayer.rc.left - 10, _subPlayer.rc.top - 30);
			}
			else
			{
				IMAGEMANAGER->findImage("subShot")->
					scaleFrameRender(getMemDC(), _subPlayer.rc.left - 10, _subPlayer.rc.top - 30,
						_subPlayer.atkshot->getFrameX(), _subPlayer.atkshot->getFrameY(), -1.0F);
			}
		}
		break;
	case pRUN:
		if (_subPlayer.sight)
		{
			IMAGEMANAGER->findImage("subRun")->frameRender(getMemDC(), _subPlayer.rc.left, _subPlayer.rc.top);
		}
		else
		{
			IMAGEMANAGER->findImage("subRun")->
				scaleFrameRender(getMemDC(), _subPlayer.rc.left, _subPlayer.rc.top,
					_subPlayer.run->getFrameX(), _subPlayer.run->getFrameY(), -1.0F);
		}
		break;
	}
	
	if (_arrow._bShoot)
	{
		IMAGEMANAGER->findImage("arrow")->render(getMemDC(), _arrow._point.x, _arrow._point.y);
	}

	char chr[100];
	sprintf(chr, "거리 : %f", _distance);
	TextOut(getMemDC(), 100, 150, chr, strlen(chr));

	char chr1[100];
	sprintf(chr1, "화살충전시간 : %f", _arrow._chargeTime);
	TextOut(getMemDC(), 100, 200, chr1, strlen(chr1));
}

void subplayer::animation()
{
	switch (_state)
	{
	case pIDLE:				  //대기상태
	{
		_frameCount++;
		_subPlayer.idle->setFrameY(0);
		if (_frameCount % 8 == 0)
		{
			_frameIndex++;
			if (_frameIndex > 2)
			{
				_frameIndex = 0;
			}
			_subPlayer.idle->setFrameX(_frameIndex);
		}
		break;
	}
	case pWALK:		//걷기
	{
		_frameCount++;
		_subPlayer.walk->setFrameY(0);
		if (_frameCount % 8 == 0)
		{
			_frameIndex++;
			if (_frameIndex > 4)
			{
				_frameIndex = 0;
			}
			_subPlayer.walk->setFrameX(_frameIndex);
		}
		break;
	}
	case pATTACK:
		if (_melee)	//근접 공격을 할 때
		{
			_frameCount++;
			_subPlayer.atkmelee->setFrameY(0);
			if (_frameCount % 8 == 0)
			{
				_frameIndex++;
				if (_frameIndex > 2)
					//근접 공격의 이미지 프레임은 2개
					//따라서 _frameIndex가 1보다 큰 경우는 공격이 끝난 것으로 판단한다.
				{
					_frameCount = 0;	//_frameCount를 0으로 초기화
					_frameIndex = 0;	//_frameIndex를 0으로 초기화
					_state = pIDLE;		//대기상태로 전환
				}
				_subPlayer.atkmelee->setFrameX(_frameIndex);
			}
		}
		else	//원거리 공격을 할 때
		{
			_frameCount++;
			_subPlayer.atkshot->setFrameY(0);
			if (_frameCount % 8 == 0)
			{
				_frameIndex++;
				if (_frameIndex > 8)
					//원거리 공격의 이미지 프레임은 8개
					//따라서 _frameIndex가 7보다 큰 경우는 공격이 끝난 것으로 판단한다.
				{
					_frameCount = 0;	//_frameCount를 0으로 초기화
					_frameIndex = 0;	//_frameIndex를 0으로 초기화
					_state = pIDLE;		//대기상태로 전환
				}
				_subPlayer.atkshot->setFrameX(_frameIndex);
			}
		}
		break;
	case pRUN:
	{
		_frameCount++;
		_subPlayer.run->setFrameY(0);
		if (_frameCount % 8 == 0)
		{
			_frameIndex++;
			if (_frameIndex > 4)
			{
				_frameIndex = 0;
			}
			_subPlayer.run->setFrameX(_frameIndex);
		}
		break;
	}
	}
}

void subplayer::walkingInfo()
//상태창에서 걷은 애니메이션 출력
{
	_frameCount++;
	switch(_direct%4)
	{
	case 0:
	{
		_walkingDirect->setFrameY(_direct);
		if (_frameCount % 10 == 0)
		{
			if (_isLeft) { _frameIndex++; }
			else { _frameIndex--; }
			if (_frameIndex == 4 || _frameIndex == 0) { _isLeft = !_isLeft; }
		}
		if (_frameCount % 90 == 0)
		{
			_direct = 3;
		}
		_walkingDirect->setFrameX(_frameIndex);
		break;
	}
	case 1:
	{
		_walkingDirect->setFrameY(_direct);
		if (_frameCount % 10 == 0)
		{
			if (_isLeft) { _frameIndex++; }
			else { _frameIndex--; }
			if (_frameIndex == 4 || _frameIndex == 0) { _isLeft = !_isLeft; }
		}
		if (_frameCount % 90 == 0)
		{
			_direct = 2;
		}
		_walkingDirect->setFrameX(_frameIndex);
		break;
	}
	case 2:
	{
		_walkingDirect->setFrameY(_direct);
		if (_frameCount % 10 == 0)
		{
			if (_isLeft) { _frameIndex++; }
			else { _frameIndex--; }
			if (_frameIndex == 4 || _frameIndex == 0) { _isLeft = !_isLeft; }
		}
		if (_frameCount % 90 == 0)
		{
			_direct = 0;
		}
		_walkingDirect->setFrameX(_frameIndex);
		break;
	}
	case 3:
	{
		_walkingDirect->setFrameY(_direct);
		if (_frameCount % 10 == 0)
		{
			if (_isLeft) { _frameIndex++; }
			else { _frameIndex--; }
			if (_frameIndex == 4 || _frameIndex == 0) { _isLeft = !_isLeft; }
		}
		if (_frameCount % 90 == 0)
		{
			_direct = 1;
		}
		_walkingDirect->setFrameX(_frameIndex);
		break;
	}
	}
}
